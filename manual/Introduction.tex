\section{Introduction}

Before diving into the API of \lib, we discuss the concepts behind it and to explain the terminology used in this manual.

\subsection{Actor Model}

The actor model describes concurrent entities---actors---that do not share state and communicate only via asynchronous message passing.
Decoupling concurrently running software components via message passing avoids race conditions by design.
Actors can create---spawn---new actors and monitor each other to build fault-tolerant, hierarchical systems.
Since message passing is network transparent, the actor model applies to both concurrency and distribution.

Implementing applications on top of low-level primitives such as mutexes and semaphores has proven challenging and error-prone.
In particular when trying to implement applications that scale up to many CPU cores.
Queueing, starvation, priority inversion, and false sharing are only a few of the issues that can decrease performance significantly in mutex-based concurrency models.
In the extreme, an application written with the classical toolkit can run slower when adding more cores.

The actor model has gained momentum over the last decade due to its high level of abstraction and its ability to scale dynamically from one core to many cores and from one node to many nodes.
However, the actor model has not yet been widely adopted in the native programming domain.
With \lib, we contribute a library for actor programming in C++ as open-source software to ease native development of concurrent as well as distributed systems.
In this regard, \lib follows the C++ philosophy ``building the highest abstraction possible without sacrificing performance''.

\subsection{Terminology}

\lib is inspired by other implementations based on the actor model such as Erlang or Akka, but aims to provide a modern C++ API allowing for type-safe as well as dynamically typed messaging.
While there are similarities to other implementations, we made many different design decisions that lead to slight differences when comparing \lib to other actor frameworks.

\subsubsection{Actor Address}

In \lib, each actor has a (network-wide) unique logical address of type \lstinline^actor_addr^ that can be used to identify and monitor it.
Unlike other actor frameworks, \lib does \emph{not} allow users to send messages to addresses.
This limitation is due to the fact that the address does not contain any type information.
Hence, it would not be safe to send it a message, because the receiving actor might use a statically typed interface that does not accept the given message.

Because an \lstinline^actor_addr^ fills the role of an identifier, it has \emph{weak pointer semantics} \see{reference-counting}.

\subsubsection{Actor Handle}

An actor handle contains the address of an actor along with its type information and is required for sending messages to actors.
The distinction between handles and addresses---which is unique to \lib when comparing it to other actor systems---is a consequence of the design decision to support both untyped and typed actors.

\subsubsection{Dynamically Typed Actor}

A dynamically typed actor accepts any kind of message and dispatches on its content dynamically at the receiver.
This is the ``traditional'' messaging style found in implementations like Erlang or Akka.
The upside of this approach is (usually) faster prototyping and less code.
This comes at the cost of requiring excessive testing.

\subsubsection{Statically Typed Actor}

\lib achieves static type-checking for actors by defining abstract messaging interfaces.
Since interfaces define both input and output types, CAF is able to verify messaging protocols statically.
The upside of this approach is much higher robustness to code changes and fewer possible runtime errors.
This comes at an increase in required source code, as developers have to define and use messaging interfaces.

\subsubsection{Spawning}

``Spawning'' an actor means to create and run a new actor.

\subsubsection{Monitoring}
\label{sec:monitoring}

A monitored actor sends a \texttt{DOWN} message to all actors monitoring it as part of its termination.
This allows actors to supervise other actors and to take actions when one of the supervised actors failed, i.e., terminated with a non-normal exit reason.

\subsubsection{Links}

A link is a bidirectional connection between two actors.
Each actor sends an \texttt{EXIT} message to all of its links as part of its termination.
Unlike \texttt{DOWN} messages~\see{monitoring}, the default behavior for received exit messages causes the receiving actor to terminate as well when receiving a non-normal exit reason.
This allows developers to create a set of actors with the guarantee that either all or no actors are alive.
The default behavior can be overridden by ``trapping'' exit messages and handling them manually.